<HTML>
<HEAD>
<TITLE>class KImageEffect</TITLE>

<META NAME="Generator" CONTENT="KDOC ">
</HEAD>
<BODY bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#000099" alink= "#ffffff">
<TABLE WIDTH="100%" BORDER="0">
<TR>
<TD>
	<TABLE BORDER="0">
		<TR><TD valign="top" align="left" cellspacing="10">
		<h1>class KImageEffect</h1>
		</TD>
		<TD valign="top" align="right" colspan="1">
 This class includes various <A HREF="#QImage">QImage</A> based graphical effects. <small><A HREF="#longdesc">More...</A></small></TD></TR>
	</TABLE>
	<HR>
	<TABLE BORDER="0">
		<TR><TH>Definition</TH><TD><code>#include &lt;<A HREF="scribus___kimageeffect_h.html">scribus/kimageeffect.h</A>&gt;</code></TD></TR>
<TR><TH><A HREF="full-list-KImageEffect.html">List of all Methods</A></TH></TR>
	</TABLE>
	</TD>
<TD align="right"><TABLE BORDER="0"><TR><TD><small><A HREF="index-long.html">Annotated List</A></small></TD></TR>
<TR><TD><small><A HREF="header-list.html">Files</A></small></TD></TR>
<TR><TD><small><A HREF="all-globals.html">Globals</A></small></TD></TR>
<TR><TD><small><A HREF="hier.html">Hierarchy</A></small></TD></TR>
<TR><TD><small><A HREF="index.html">Index</A></small></TD></TR>
</TABLE></TD></TR></TABLE>
<h4>Public Types</h4><ul><LI>enum <A HREF="#ref1">GradientType</A> { VerticalGradient, HorizontalGradient,
                        DiagonalGradient, CrossDiagonalGradient,
                        PyramidGradient, RectangleGradient,
                        PipeCrossGradient, EllipticGradient }
</LI>
<LI>enum <A HREF="#ref2">RGBComponent</A> { Red, Green, Blue, Gray, All }
</LI>
<LI>enum <A HREF="#ref3">Lighting</A> {NorthLite, NWLite, WestLite, SWLite,
                   SouthLite, SELite, EastLite, NELite}
</LI>
<LI>enum <A HREF="#ref4">ModulationType</A> { Intensity, Saturation, HueShift, Contrast }
</LI>
<LI>enum <A HREF="#ref5">NoiseType</A> { UniformNoise=0, GaussianNoise, MultiplicativeGaussianNoise,
                     ImpulseNoise, LaplacianNoise, PoissonNoise}
</LI>
<LI>enum <A HREF="#ref6">RotateDirection</A> { Rotate90, Rotate180, Rotate270 }
</LI>
</ul><h4>Public Static Methods</h4><ul><LI>static  <A HREF="#QImage">QImage</A> &nbsp;<b><A HREF="#ref7">gradient</A></b> (const <A HREF="#QSize">QSize</A> &size, const <A HREF="#QColor">QColor</A> &ca,
                           const <A HREF="#QColor">QColor</A> &cb, GradientType type, int ncols=3) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A> &nbsp;<b><A HREF="#ref8">unbalancedGradient</A></b> (const <A HREF="#QSize">QSize</A> &size, const <A HREF="#QColor">QColor</A> &ca,
	    const <A HREF="#QColor">QColor</A> &cb, GradientType type, int xfactor = 100,
	    int yfactor = 100, int ncols = 3) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A>& &nbsp;<b><A HREF="#ref9">blend</A></b> (const <A HREF="#QColor">QColor</A>& clr, <A HREF="#QImage">QImage</A>& dst, float opacity) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A>& &nbsp;<b><A HREF="#ref10">blend</A></b> (<A HREF="#QImage">QImage</A>& src, <A HREF="#QImage">QImage</A>& dst, float opacity) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A>& &nbsp;<b><A HREF="#ref11">blend</A></b> (<A HREF="#QImage">QImage</A> &image, float initial_intensity,
                      const <A HREF="#QColor">QColor</A> &bgnd, GradientType eff,
                      bool anti_dir=false) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A>& &nbsp;<b><A HREF="#ref12">blend</A></b> (<A HREF="#QImage">QImage</A> &image1,<A HREF="#QImage">QImage</A> &image2,
			 GradientType gt, int xf=100, int yf=100) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A>& &nbsp;<b><A HREF="#ref13">blend</A></b> (<A HREF="#QImage">QImage</A> &image1, <A HREF="#QImage">QImage</A> &image2,
			 <A HREF="#QImage">QImage</A> &blendImage, RGBComponent channel) 
</LI>
<LI>static  bool &nbsp;<b><A HREF="#ref14">blend</A></b> (const <A HREF="#QImage">QImage</A> & upper, const <A HREF="#QImage">QImage</A> & lower, <A HREF="#QImage">QImage</A> & output) 
</LI>
<LI>static  bool &nbsp;<b><A HREF="#ref15">blend</A></b> (int &x, int &y, const <A HREF="#QImage">QImage</A> & upper, const <A HREF="#QImage">QImage</A> & lower, <A HREF="#QImage">QImage</A> & output) 
</LI>
<LI>static  bool &nbsp;<b><A HREF="#ref16">blendOnLower</A></b> (int x, int y, const <A HREF="#QImage">QImage</A> & upper, const <A HREF="#QImage">QImage</A> & lower) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A>& &nbsp;<b><A HREF="#ref17">channelIntensity</A></b> (<A HREF="#QImage">QImage</A> &image, float percent,
                                    RGBComponent channel) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A>& &nbsp;<b><A HREF="#ref18">fade</A></b> (<A HREF="#QImage">QImage</A> &img, float val, const <A HREF="#QColor">QColor</A> &color) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A>& &nbsp;<b><A HREF="#ref19">flatten</A></b> (<A HREF="#QImage">QImage</A> &image, const <A HREF="#QColor">QColor</A> &ca,
           const <A HREF="#QColor">QColor</A> &cb, int ncols=0) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A>& &nbsp;<b><A HREF="#ref20">hash</A></b> (<A HREF="#QImage">QImage</A> &image, Lighting lite=NorthLite,
                        unsigned int spacing=0) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A>& &nbsp;<b><A HREF="#ref21">intensity</A></b> (<A HREF="#QImage">QImage</A> &image, float percent) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A>& &nbsp;<b><A HREF="#ref22">modulate</A></b> (<A HREF="#QImage">QImage</A> &image, <A HREF="#QImage">QImage</A> &modImage, bool reverse,
		ModulationType type, int factor, RGBComponent channel) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A>& &nbsp;<b><A HREF="#ref23">toGray</A></b> (<A HREF="#QImage">QImage</A> &image, bool fast = false) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A>& &nbsp;<b><A HREF="#ref24">desaturate</A></b> (<A HREF="#QImage">QImage</A> &image, float desat = 0.3) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A>& &nbsp;<b><A HREF="#ref25">contrast</A></b> (<A HREF="#QImage">QImage</A> &image, int c) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A>& &nbsp;<b><A HREF="#ref26">dither</A></b> (<A HREF="#QImage">QImage</A> &img, const <A HREF="#QColor">QColor</A> *palette, int size) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A>& &nbsp;<b><A HREF="#ref27">selectedImage</A></b> ( <A HREF="#QImage">QImage</A> &img, const <A HREF="#QColor">QColor</A> &col ) 
</LI>
<LI>static  void &nbsp;<b><A HREF="#ref28">contrastHSV</A></b> (<A HREF="#QImage">QImage</A> &img, bool sharpen=true) 
</LI>
<LI>static  void &nbsp;<b><A HREF="#ref29">normalize</A></b> (<A HREF="#QImage">QImage</A> &img) 
</LI>
<LI>static  void &nbsp;<b><A HREF="#ref30">equalize</A></b> (<A HREF="#QImage">QImage</A> &img) 
</LI>
<LI>static  void &nbsp;<b><A HREF="#ref31">threshold</A></b> (<A HREF="#QImage">QImage</A> &img, unsigned int value=128) 
</LI>
<LI>static  void &nbsp;<b><A HREF="#ref32">solarize</A></b> (<A HREF="#QImage">QImage</A> &img, double factor=50.0) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A> &nbsp;<b><A HREF="#ref33">emboss</A></b> (<A HREF="#QImage">QImage</A> &src) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A> &nbsp;<b><A HREF="#ref34">despeckle</A></b> (<A HREF="#QImage">QImage</A> &src) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A> &nbsp;<b><A HREF="#ref35">charcoal</A></b> (<A HREF="#QImage">QImage</A> &src, double factor=50.0) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A> &nbsp;<b><A HREF="#ref36">rotate</A></b> (<A HREF="#QImage">QImage</A> &src, RotateDirection r) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A> &nbsp;<b><A HREF="#ref37">sample</A></b> (<A HREF="#QImage">QImage</A> &src, int w, int h) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A> &nbsp;<b><A HREF="#ref38">addNoise</A></b> (<A HREF="#QImage">QImage</A> &src, NoiseType type = GaussianNoise) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A> &nbsp;<b><A HREF="#ref39">blur</A></b> (<A HREF="#QImage">QImage</A> &src, double factor=50.0) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A> &nbsp;<b><A HREF="#ref40">edge</A></b> (<A HREF="#QImage">QImage</A> &src, double factor=50.0) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A> &nbsp;<b><A HREF="#ref41">implode</A></b> (<A HREF="#QImage">QImage</A> &src, double factor=30.0,
                   unsigned int background = 0xFFFFFFFF) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A> &nbsp;<b><A HREF="#ref42">oilPaint</A></b> (<A HREF="#QImage">QImage</A> &src, int radius=3) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A> &nbsp;<b><A HREF="#ref43">sharpen</A></b> (<A HREF="#QImage">QImage</A> &src, double factor=30.0) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A> &nbsp;<b><A HREF="#ref44">spread</A></b> (<A HREF="#QImage">QImage</A> &src, unsigned int amount=3) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A> &nbsp;<b><A HREF="#ref45">shade</A></b> (<A HREF="#QImage">QImage</A> &src, bool color_shading=true, double azimuth=30.0,
                        double elevation=30.0) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A> &nbsp;<b><A HREF="#ref46">swirl</A></b> (<A HREF="#QImage">QImage</A> &src, double degrees=50.0, unsigned int background =
                         0xFFFFFFFF) 
</LI>
<LI>static  <A HREF="#QImage">QImage</A> &nbsp;<b><A HREF="#ref47">wave</A></b> (<A HREF="#QImage">QImage</A> &src, double amplitude=25.0, double frequency=150.0,
                        unsigned int background = 0xFFFFFFFF) 
</LI>
</ul><h4>Private Static Methods</h4><ul><LI>static  unsigned int &nbsp;<b><A HREF="#ref48">lHash</A></b> (unsigned int c) 
</LI>
<LI>static  unsigned int &nbsp;<b><A HREF="#ref49">uHash</A></b> (unsigned int c) 
</LI>
<LI>static  int &nbsp;<b><A HREF="#ref50">nearestColor</A></b> ( int r, int g, int b, const <A HREF="#QColor">QColor</A> *pal, int size ) 
</LI>
<LI>static  void &nbsp;<b><A HREF="#ref51">hull</A></b> (const int x_offset, const int y_offset, const int polarity,
                     const int width, const int height,
                     unsigned int *f, unsigned int *g) 
</LI>
<LI>static  unsigned int &nbsp;<b><A HREF="#ref52">generateNoise</A></b> (unsigned int pixel, NoiseType type) 
</LI>
<LI>static  unsigned int &nbsp;<b><A HREF="#ref53">interpolateColor</A></b> (<A HREF="#QImage">QImage</A> *image, double x, double y,
                                         unsigned int background) 
</LI>
</ul><HR><H2><A NAME="longdesc">Detailed Description</A></H2><p>
 This class includes various <A HREF="#QImage">QImage</A> based graphical effects.
</p>
<p> Everything is
 static, so there is no need to create an instance of this class. You can
 just call the static methods. They are encapsulated here merely to provide
 a common namespace.
 </p>
<A NAME="GradientType"></A><A NAME="ref1"></A><table width="100%"><tr bgcolor="#eeeeee"><td>enum <strong>GradientType</strong> { VerticalGradient, HorizontalGradient,
                        DiagonalGradient, CrossDiagonalGradient,
                        PyramidGradient, RectangleGradient,
                        PipeCrossGradient, EllipticGradient }
</td><td align="right"><h3><strong>GradientType</strong></h3></td></tr></table><p></p><A NAME="RGBComponent"></A><A NAME="ref2"></A><table width="100%"><tr bgcolor="#eeeeee"><td>enum <strong>RGBComponent</strong> { Red, Green, Blue, Gray, All }
</td><td align="right"><h3><strong>RGBComponent</strong></h3></td></tr></table><p></p><A NAME="Lighting"></A><A NAME="ref3"></A><table width="100%"><tr bgcolor="#eeeeee"><td>enum <strong>Lighting</strong> {NorthLite, NWLite, WestLite, SWLite,
                   SouthLite, SELite, EastLite, NELite}
</td><td align="right"><h3><strong>Lighting</strong></h3></td></tr></table><p></p><A NAME="ModulationType"></A><A NAME="ref4"></A><table width="100%"><tr bgcolor="#eeeeee"><td>enum <strong>ModulationType</strong> { Intensity, Saturation, HueShift, Contrast }
</td><td align="right"><h3><strong>ModulationType</strong></h3></td></tr></table><p></p><A NAME="NoiseType"></A><A NAME="ref5"></A><table width="100%"><tr bgcolor="#eeeeee"><td>enum <strong>NoiseType</strong> { UniformNoise=0, GaussianNoise, MultiplicativeGaussianNoise,
                     ImpulseNoise, LaplacianNoise, PoissonNoise}
</td><td align="right"><h3><strong>NoiseType</strong></h3></td></tr></table><p></p><A NAME="RotateDirection"></A><A NAME="ref6"></A><table width="100%"><tr bgcolor="#eeeeee"><td>enum <strong>RotateDirection</strong> { Rotate90, Rotate180, Rotate270 }
</td><td align="right"><h3><strong>RotateDirection</strong></h3></td></tr></table><p></p><A NAME="gradient"></A><A NAME="ref7"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A> &nbsp;<strong>gradient</strong> (const <A HREF="#QSize">QSize</A> &size, const <A HREF="#QColor">QColor</A> &ca,
                           const <A HREF="#QColor">QColor</A> &cb, GradientType type, int ncols=3)
<br></td><td align="right"><h3><strong>gradient</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Create a gradient from color a to color b of the specified type.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>size</i></TD><TD align="left" valign="top">The desired size of the gradient.
</TD></TR>
<TR><TD align="left" valign="top"><i>ca</i></TD><TD align="left" valign="top">Color a
</TD></TR>
<TR><TD align="left" valign="top"><i>cb</i></TD><TD align="left" valign="top">Color b
</TD></TR>
<TR><TD align="left" valign="top"><i>type</i></TD><TD align="left" valign="top">The type of gradient.
</TD></TR>
<TR><TD align="left" valign="top"><i>ncols</i></TD><TD align="left" valign="top">The number of colors to use when not running on a
 truecolor display. The gradient will be dithered to this number of
 colors. Pass 0 to prevent dithering.
     </TD></TR>
</TABLE></P>
<A NAME="unbalancedGradient"></A><A NAME="ref8"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A> &nbsp;<strong>unbalancedGradient</strong> (const <A HREF="#QSize">QSize</A> &size, const <A HREF="#QColor">QColor</A> &ca,
	    const <A HREF="#QColor">QColor</A> &cb, GradientType type, int xfactor = 100,
	    int yfactor = 100, int ncols = 3)
<br></td><td align="right"><h3><strong>unbalancedGradient</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Create an unbalanced gradient.
</p>
<p> An unbalanced gradient is a gradient where the transition from
 color a to color b is not linear, but in this case, exponential.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>size</i></TD><TD align="left" valign="top">The desired size of the gradient.
</TD></TR>
<TR><TD align="left" valign="top"><i>ca</i></TD><TD align="left" valign="top">Color a
</TD></TR>
<TR><TD align="left" valign="top"><i>cb</i></TD><TD align="left" valign="top">Color b
</TD></TR>
<TR><TD align="left" valign="top"><i>type</i></TD><TD align="left" valign="top">The type of gradient.
</TD></TR>
<TR><TD align="left" valign="top"><i>xfactor</i></TD><TD align="left" valign="top">The x decay length. Use a value between -200 and 200.
</TD></TR>
<TR><TD align="left" valign="top"><i>yfactor</i></TD><TD align="left" valign="top">The y decay length.
</TD></TR>
<TR><TD align="left" valign="top"><i>ncols</i></TD><TD align="left" valign="top">The number of colors. See KPixmapEffect:gradient.
     </TD></TR>
</TABLE></P>
<A NAME="blend"></A><A NAME="ref9"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A>& &nbsp;<strong>blend</strong> (const <A HREF="#QColor">QColor</A>& clr, <A HREF="#QImage">QImage</A>& dst, float opacity)
<br></td><td align="right"><h3><strong>blend</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Blends a color into the destination image, using an opacity
 value for blending one into another. Very fast direct pixel
 manipulation is used.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>clr</i></TD><TD align="left" valign="top">source color to be blended into the destination image.
</TD></TR>
<TR><TD align="left" valign="top"><i>dst</i></TD><TD align="left" valign="top">destination image in which the source will be blended into.
</TD></TR>
<TR><TD align="left" valign="top"><i>opacity</i></TD><TD align="left" valign="top">opacity (in percent) which determines how much the source
                color will be blended into the destination image.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The destination image (dst) containing the result.
     </p>
<A NAME="blend"></A><A NAME="ref10"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A>& &nbsp;<strong>blend</strong> (<A HREF="#QImage">QImage</A>& src, <A HREF="#QImage">QImage</A>& dst, float opacity)
<br></td><td align="right"><h3><strong>blend</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Blend the src image into the destination image, using an opacity
 value for blending one into another. Very fast direct pixel
 manipulation is used.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>src</i></TD><TD align="left" valign="top">source image to be blended into the destination image.
</TD></TR>
<TR><TD align="left" valign="top"><i>dst</i></TD><TD align="left" valign="top">destination image in which the source will be blended into.
</TD></TR>
<TR><TD align="left" valign="top"><i>opacity</i></TD><TD align="left" valign="top">opacity (in percent) which determines how much the source
                image will be blended into the destination image.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The destination image (dst) containing the result.
     </p>
<A NAME="blend"></A><A NAME="ref11"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A>& &nbsp;<strong>blend</strong> (<A HREF="#QImage">QImage</A> &image, float initial_intensity,
                      const <A HREF="#QColor">QColor</A> &bgnd, GradientType eff,
                      bool anti_dir=false)
<br></td><td align="right"><h3><strong>blend</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Blend the provided image into a background of the indicated color.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>initial_intensity</i></TD><TD align="left" valign="top">this parameter takes values from -1 to 1:
              a) if positive: how much to fade the image in its
                              less affected spot
              b) if negative: roughly indicates how much of the image
                              remains unaffected
</TD></TR>
<TR><TD align="left" valign="top"><i>bgnd</i></TD><TD align="left" valign="top">indicates the color of the background to blend in
</TD></TR>
<TR><TD align="left" valign="top"><i>eff</i></TD><TD align="left" valign="top">lets you choose what kind of blending you like
</TD></TR>
<TR><TD align="left" valign="top"><i>anti_dir</i></TD><TD align="left" valign="top">blend in the opposite direction (makes no much sense
                  with concentric blending effects)
</TD></TR>
<TR><TD align="left" valign="top"><i>image</i></TD><TD align="left" valign="top">must be 32bpp
     </TD></TR>
</TABLE></P>
<A NAME="blend"></A><A NAME="ref12"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A>& &nbsp;<strong>blend</strong> (<A HREF="#QImage">QImage</A> &image1,<A HREF="#QImage">QImage</A> &image2,
			 GradientType gt, int xf=100, int yf=100)
<br></td><td align="right"><h3><strong>blend</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Blend an image into another one, using a gradient type
 for blending from one to another.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>image1</i></TD><TD align="left" valign="top">source1 and result of blending
</TD></TR>
<TR><TD align="left" valign="top"><i>image2</i></TD><TD align="left" valign="top">source2 of blending
</TD></TR>
<TR><TD align="left" valign="top"><i>gt</i></TD><TD align="left" valign="top">gradient type for blending between source1 and source2
</TD></TR>
<TR><TD align="left" valign="top"><i>xf</i></TD><TD align="left" valign="top">x decay length for unbalanced gradient tpye
</TD></TR>
<TR><TD align="left" valign="top"><i>yf</i></TD><TD align="left" valign="top">y decay length for unbalanced gradient tpye
     </TD></TR>
</TABLE></P>
<A NAME="blend"></A><A NAME="ref13"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A>& &nbsp;<strong>blend</strong> (<A HREF="#QImage">QImage</A> &image1, <A HREF="#QImage">QImage</A> &image2,
			 <A HREF="#QImage">QImage</A> &blendImage, RGBComponent channel)
<br></td><td align="right"><h3><strong>blend</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Blend an image into another one, using a color channel of a
 third image for the decision of blending from one to another.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>image1</i></TD><TD align="left" valign="top">Source 1 and result of blending
</TD></TR>
<TR><TD align="left" valign="top"><i>image2</i></TD><TD align="left" valign="top">Source 2 of blending
</TD></TR>
<TR><TD align="left" valign="top"><i>blendImage</i></TD><TD align="left" valign="top">If the gray value of of pixel is 0, the result
               for this pixel is that of image1; for a gray value
               of 1, the pixel of image2 is used; for a value
               inbetween, a corresponding blending is used.
</TD></TR>
<TR><TD align="left" valign="top"><i>channel</i></TD><TD align="left" valign="top">The RBG channel to use for the blending decision.
     </TD></TR>
</TABLE></P>
<A NAME="blend"></A><A NAME="ref14"></A><table width="100%"><tr bgcolor="#eeeeee"><td> bool &nbsp;<strong>blend</strong> (const <A HREF="#QImage">QImage</A> & upper, const <A HREF="#QImage">QImage</A> & lower, <A HREF="#QImage">QImage</A> & output)
<br></td><td align="right"><h3><strong>blend</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Blend an image into another one, using alpha in the expected way.
</p>
<A NAME="blend"></A><A NAME="ref15"></A><table width="100%"><tr bgcolor="#eeeeee"><td> bool &nbsp;<strong>blend</strong> (int &x, int &y, const <A HREF="#QImage">QImage</A> & upper, const <A HREF="#QImage">QImage</A> & lower, <A HREF="#QImage">QImage</A> & output)
<br></td><td align="right"><h3><strong>blend</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Blend an image into another one, using alpha in the expected way and
 over coordinates <code>x</code> and <code>y</code> with respect to the lower image.
 The output is a QImage which is the <code>upper</code> image already blended
 with the <code>lower</code> one, so its size will be (in general) the same than
 <code>upper</code> instead of the same size than <code>lower</code> like the method above.
 In fact, the size of <code>output</code> is like upper's one only when it can be
 painted on lower, if there has to be some clipping, output's size will
 be the clipped area and x and y will be set to the correct up-left corner
 where the clipped rectangle begins.
     </p>
<A NAME="blendOnLower"></A><A NAME="ref16"></A><table width="100%"><tr bgcolor="#eeeeee"><td> bool &nbsp;<strong>blendOnLower</strong> (int x, int y, const <A HREF="#QImage">QImage</A> & upper, const <A HREF="#QImage">QImage</A> & lower)
<br></td><td align="right"><h3><strong>blendOnLower</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Blend an image into another one, using alpha in the expected way and
 over coordinates <code>x</code> and <code>y</code> with respect to the lower image.
 The output is painted in the own <code>lower</code> image. This is an optimization
 of the <A HREF="KImageEffect.html#blend">blend</A> method above provided by convenience.
     </p>
<A NAME="channelIntensity"></A><A NAME="ref17"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A>& &nbsp;<strong>channelIntensity</strong> (<A HREF="#QImage">QImage</A> &image, float percent,
                                    RGBComponent channel)
<br></td><td align="right"><h3><strong>channelIntensity</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Modifies the intensity of a pixmap's RGB channel component.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>image</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>percent</i></TD><TD align="left" valign="top">Percent value. Use a negative value to dim.
</TD></TR>
<TR><TD align="left" valign="top"><i>channel</i></TD><TD align="left" valign="top">Which channel(s) should be modified
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The <code>image</code>, provided for convenience.
     </p>
<A NAME="fade"></A><A NAME="ref18"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A>& &nbsp;<strong>fade</strong> (<A HREF="#QImage">QImage</A> &img, float val, const <A HREF="#QColor">QColor</A> &color)
<br></td><td align="right"><h3><strong>fade</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Fade an image to a certain background color.
</p>
<p> The number of colors will not be changed.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>image</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>val</i></TD><TD align="left" valign="top">The strength of the effect. 0 <= val <= 1.
</TD></TR>
<TR><TD align="left" valign="top"><i>color</i></TD><TD align="left" valign="top">The background color.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Returns the image(), provided for convenience.
     </p>
<A NAME="flatten"></A><A NAME="ref19"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A>& &nbsp;<strong>flatten</strong> (<A HREF="#QImage">QImage</A> &image, const <A HREF="#QColor">QColor</A> &ca,
           const <A HREF="#QColor">QColor</A> &cb, int ncols=0)
<br></td><td align="right"><h3><strong>flatten</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 This recolors a pixmap. The most dark color will become color a,
 the most bright one color b, and in between.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>image</i></TD><TD align="left" valign="top">A QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>ca</i></TD><TD align="left" valign="top">Color a
</TD></TR>
<TR><TD align="left" valign="top"><i>cb</i></TD><TD align="left" valign="top">Color b
     </TD></TR>
</TABLE></P>
<A NAME="hash"></A><A NAME="ref20"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A>& &nbsp;<strong>hash</strong> (<A HREF="#QImage">QImage</A> &image, Lighting lite=NorthLite,
                        unsigned int spacing=0)
<br></td><td align="right"><h3><strong>hash</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Build a hash on any given <A HREF="#QImage">QImage</A>
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>image</i></TD><TD align="left" valign="top">The QImage to process
</TD></TR>
<TR><TD align="left" valign="top"><i>lite</i></TD><TD align="left" valign="top">The hash faces the indicated lighting (cardinal poles).
</TD></TR>
<TR><TD align="left" valign="top"><i>spacing</i></TD><TD align="left" valign="top">How many unmodified pixels inbetween hashes.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Returns the image(), provided for convenience.
     </p>
<A NAME="intensity"></A><A NAME="ref21"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A>& &nbsp;<strong>intensity</strong> (<A HREF="#QImage">QImage</A> &image, float percent)
<br></td><td align="right"><h3><strong>intensity</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Either brighten or dim the image by a specified percent.
 For example, .50 will modify the colors by 50%.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>image</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>percent</i></TD><TD align="left" valign="top">The percent value. Use a negative value to dim.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Returns The image(), provided for convenience.
     </p>
<A NAME="modulate"></A><A NAME="ref22"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A>& &nbsp;<strong>modulate</strong> (<A HREF="#QImage">QImage</A> &image, <A HREF="#QImage">QImage</A> &modImage, bool reverse,
		ModulationType type, int factor, RGBComponent channel)
<br></td><td align="right"><h3><strong>modulate</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Modulate the image with a color channel of another image.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>image</i></TD><TD align="left" valign="top">The QImage to modulate and result.
</TD></TR>
<TR><TD align="left" valign="top"><i>modImage</i></TD><TD align="left" valign="top">The QImage to use for modulation.
</TD></TR>
<TR><TD align="left" valign="top"><i>reverse</i></TD><TD align="left" valign="top">Invert the meaning of image/modImage; result is image!
</TD></TR>
<TR><TD align="left" valign="top"><i>type</i></TD><TD align="left" valign="top">The modulation Type to use.
</TD></TR>
<TR><TD align="left" valign="top"><i>factor</i></TD><TD align="left" valign="top">The modulation amplitude; with 0 no effect [-200;200].
</TD></TR>
<TR><TD align="left" valign="top"><i>channel</i></TD><TD align="left" valign="top">The RBG channel of image2 to use for modulation.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Returns the image(), provided for convenience.
     </p>
<A NAME="toGray"></A><A NAME="ref23"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A>& &nbsp;<strong>toGray</strong> (<A HREF="#QImage">QImage</A> &image, bool fast = false)
<br></td><td align="right"><h3><strong>toGray</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Convert an image to grayscale.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>image</i></TD><TD align="left" valign="top">The <A HREF="#QImage">QImage</A> to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>fast</i></TD><TD align="left" valign="top">Set to <code>true</code> in order to use a faster but non-photographic
 quality algorithm. Appropriate for things such as toolbar icons.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Returns the image(), provided for convenience.
     </p>
<A NAME="desaturate"></A><A NAME="ref24"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A>& &nbsp;<strong>desaturate</strong> (<A HREF="#QImage">QImage</A> &image, float desat = 0.3)
<br></td><td align="right"><h3><strong>desaturate</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Desaturate an image evenly.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>image</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>desat</i></TD><TD align="left" valign="top">A value between 0 and 1 setting the degree of desaturation
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Returns the image(), provided for convenience.
     </p>
<A NAME="contrast"></A><A NAME="ref25"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A>& &nbsp;<strong>contrast</strong> (<A HREF="#QImage">QImage</A> &image, int c)
<br></td><td align="right"><h3><strong>contrast</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Fast, but low quality contrast of an image. Also see contrastHSV.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>image</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>c</i></TD><TD align="left" valign="top">A contrast value between -255 to 255.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The image(), provided for convenience.
     </p>
<A NAME="dither"></A><A NAME="ref26"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A>& &nbsp;<strong>dither</strong> (<A HREF="#QImage">QImage</A> &img, const <A HREF="#QColor">QColor</A> *palette, int size)
<br></td><td align="right"><h3><strong>dither</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Dither an image using Floyd-Steinberg dithering for low-color
 situations.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>image</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>palette</i></TD><TD align="left" valign="top">The color palette to use
</TD></TR>
<TR><TD align="left" valign="top"><i>size</i></TD><TD align="left" valign="top">The size of the palette
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Returns the image(), provided for convenience.
     </p>
<A NAME="selectedImage"></A><A NAME="ref27"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A>& &nbsp;<strong>selectedImage</strong> ( <A HREF="#QImage">QImage</A> &img, const <A HREF="#QColor">QColor</A> &col )
<br></td><td align="right"><h3><strong>selectedImage</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Calculate the image for a selected image, for instance a selected icon
 on the desktop.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>img</i></TD><TD align="left" valign="top">the QImage to select
</TD></TR>
<TR><TD align="left" valign="top"><i>col</i></TD><TD align="left" valign="top">the selected color, usually from QColorGroup::highlight().
     </TD></TR>
</TABLE></P>
<A NAME="contrastHSV"></A><A NAME="ref28"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>contrastHSV</strong> (<A HREF="#QImage">QImage</A> &img, bool sharpen=true)
<br></td><td align="right"><h3><strong>contrastHSV</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 High quality, expensive HSV contrast. You can do a faster one by just
 taking a intensity threshold (ie: 128) and incrementing RGB color
 channels above it and decrementing those below it, but this gives much
 better results.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>img</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>sharpen</i></TD><TD align="left" valign="top">If true sharpness is increase, (spiffed). Otherwise
 it is decreased, (dulled).
     </TD></TR>
</TABLE></P>
<A NAME="normalize"></A><A NAME="ref29"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>normalize</strong> (<A HREF="#QImage">QImage</A> &img)
<br></td><td align="right"><h3><strong>normalize</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Normalizes the pixel values to span the full range of color values.
 This is a contrast enhancement technique.
</p>
<A NAME="equalize"></A><A NAME="ref30"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>equalize</strong> (<A HREF="#QImage">QImage</A> &img)
<br></td><td align="right"><h3><strong>equalize</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Performs histogram equalization on the reference
 image.
</p>
<A NAME="threshold"></A><A NAME="ref31"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>threshold</strong> (<A HREF="#QImage">QImage</A> &img, unsigned int value=128)
<br></td><td align="right"><h3><strong>threshold</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Thresholds the reference image. You can also threshold images by using
 ThresholdDither in the various QPixmap/QImage convert methods, but this
 lets you specify a threshold value.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>img</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>value</i></TD><TD align="left" valign="top">The threshold value.
     </TD></TR>
</TABLE></P>
<A NAME="solarize"></A><A NAME="ref32"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>solarize</strong> (<A HREF="#QImage">QImage</A> &img, double factor=50.0)
<br></td><td align="right"><h3><strong>solarize</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Produces a 'solarization' effect seen when exposing a photographic
 film to light during the development process.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>img</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>factor</i></TD><TD align="left" valign="top">The extent of the solarization (0-99.9)
     </TD></TR>
</TABLE></P>
<A NAME="emboss"></A><A NAME="ref33"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A> &nbsp;<strong>emboss</strong> (<A HREF="#QImage">QImage</A> &src)
<br></td><td align="right"><h3><strong>emboss</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Embosses the source image. This involves highlighting the edges
 and applying various other enhancements in order to get a metal
 effect.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>src</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The embossed image. The original is not changed.
     </p>
<A NAME="despeckle"></A><A NAME="ref34"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A> &nbsp;<strong>despeckle</strong> (<A HREF="#QImage">QImage</A> &src)
<br></td><td align="right"><h3><strong>despeckle</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Minimizes speckle noise in the source image using the 8 hull
 algorithm.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>src</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The despeckled image. The original is not changed.
     </p>
<A NAME="charcoal"></A><A NAME="ref35"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A> &nbsp;<strong>charcoal</strong> (<A HREF="#QImage">QImage</A> &src, double factor=50.0)
<br></td><td align="right"><h3><strong>charcoal</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Produces a neat little "charcoal" effect.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>src</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>factor</i></TD><TD align="left" valign="top">The factor for detecting lines (0-99.0).
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The charcoal image. The original is not changed.
     </p>
<A NAME="rotate"></A><A NAME="ref36"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A> &nbsp;<strong>rotate</strong> (<A HREF="#QImage">QImage</A> &src, RotateDirection r)
<br></td><td align="right"><h3><strong>rotate</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Rotates the image by the specified amount
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>src</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>r</i></TD><TD align="left" valign="top">The rotate direction.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The rotated image. The original is not changed.
     </p>
<A NAME="sample"></A><A NAME="ref37"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A> &nbsp;<strong>sample</strong> (<A HREF="#QImage">QImage</A> &src, int w, int h)
<br></td><td align="right"><h3><strong>sample</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Scales an image using simple pixel sampling. This does not produce
 nearly as nice a result as QImage::smoothScale(), but has the
 advantage of being much faster - only a few milliseconds.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>src</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>w</i></TD><TD align="left" valign="top">The new width.
</TD></TR>
<TR><TD align="left" valign="top"><i>h</i></TD><TD align="left" valign="top">The new height.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The scaled image. The original is not changed.
     </p>
<A NAME="addNoise"></A><A NAME="ref38"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A> &nbsp;<strong>addNoise</strong> (<A HREF="#QImage">QImage</A> &src, NoiseType type = GaussianNoise)
<br></td><td align="right"><h3><strong>addNoise</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Adds noise to an image.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>src</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>type</i></TD><TD align="left" valign="top">The algorithm used to generate the noise.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The image with noise added. The original is not changed.
     </p>
<A NAME="blur"></A><A NAME="ref39"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A> &nbsp;<strong>blur</strong> (<A HREF="#QImage">QImage</A> &src, double factor=50.0)
<br></td><td align="right"><h3><strong>blur</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Blurs an image by convolving pixel neighborhoods.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>src</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>factor</i></TD><TD align="left" valign="top">The percent weight to give to the center pixel.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The blurred image. The original is not changed.
     </p>
<A NAME="edge"></A><A NAME="ref40"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A> &nbsp;<strong>edge</strong> (<A HREF="#QImage">QImage</A> &src, double factor=50.0)
<br></td><td align="right"><h3><strong>edge</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Detects edges in an image using pixel neighborhoods and an edge
 detection mask.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>src</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>factor</i></TD><TD align="left" valign="top">The percent weight to give to the center pixel.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The image with edges detected. The original is not changed.
     </p>
<A NAME="implode"></A><A NAME="ref41"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A> &nbsp;<strong>implode</strong> (<A HREF="#QImage">QImage</A> &src, double factor=30.0,
                   unsigned int background = 0xFFFFFFFF)
<br></td><td align="right"><h3><strong>implode</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Implodes an image by a specified percent.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>src</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>factor</i></TD><TD align="left" valign="top">The extent of the implosion.
</TD></TR>
<TR><TD align="left" valign="top"><i>background</i></TD><TD align="left" valign="top">An RGBA value to use for the background. After the
 effect some pixels may be "empty". This value is used for those pixels.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The imploded image. The original is not changed.
     </p>
<A NAME="oilPaint"></A><A NAME="ref42"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A> &nbsp;<strong>oilPaint</strong> (<A HREF="#QImage">QImage</A> &src, int radius=3)
<br></td><td align="right"><h3><strong>oilPaint</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Produces an oil painting effect.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>src</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>radius</i></TD><TD align="left" valign="top">The radius of the pixel neighborhood used in applying the
 effect.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The new image. The original is not changed.
     </p>
<A NAME="sharpen"></A><A NAME="ref43"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A> &nbsp;<strong>sharpen</strong> (<A HREF="#QImage">QImage</A> &src, double factor=30.0)
<br></td><td align="right"><h3><strong>sharpen</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Sharpens the pixels in the image using pixel neighborhoods.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>src</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>factor</i></TD><TD align="left" valign="top">The percent weight to give to the center pixel.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The sharpened image. The original is not changed.
     </p>
<A NAME="spread"></A><A NAME="ref44"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A> &nbsp;<strong>spread</strong> (<A HREF="#QImage">QImage</A> &src, unsigned int amount=3)
<br></td><td align="right"><h3><strong>spread</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Randomly displaces pixels.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>src</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>amount</i></TD><TD align="left" valign="top">The vicinity for choosing a random pixel to swap.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The image with pixels displaced. The original is not changed.
     </p>
<A NAME="shade"></A><A NAME="ref45"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A> &nbsp;<strong>shade</strong> (<A HREF="#QImage">QImage</A> &src, bool color_shading=true, double azimuth=30.0,
                        double elevation=30.0)
<br></td><td align="right"><h3><strong>shade</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Shades the image using a distance light source.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>src</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>color_shading</i></TD><TD align="left" valign="top">If true do color shading, otherwise do grayscale.
</TD></TR>
<TR><TD align="left" valign="top"><i>azimuth</i></TD><TD align="left" valign="top">Determines the light source and direction.
</TD></TR>
<TR><TD align="left" valign="top"><i>elevation</i></TD><TD align="left" valign="top">Determines the light source and direction.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The shaded image. The original is not changed.
     </p>
<A NAME="swirl"></A><A NAME="ref46"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A> &nbsp;<strong>swirl</strong> (<A HREF="#QImage">QImage</A> &src, double degrees=50.0, unsigned int background =
                         0xFFFFFFFF)
<br></td><td align="right"><h3><strong>swirl</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Swirls the image by a specified amount
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>src</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>degrees</i></TD><TD align="left" valign="top">The tightness of the swirl.
</TD></TR>
<TR><TD align="left" valign="top"><i>background</i></TD><TD align="left" valign="top">An RGBA value to use for the background. After the
 effect some pixels may be "empty". This value is used for those pixels.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The swirled image. The original is not changed.
     </p>
<A NAME="wave"></A><A NAME="ref47"></A><table width="100%"><tr bgcolor="#eeeeee"><td> <A HREF="#QImage">QImage</A> &nbsp;<strong>wave</strong> (<A HREF="#QImage">QImage</A> &src, double amplitude=25.0, double frequency=150.0,
                        unsigned int background = 0xFFFFFFFF)
<br></td><td align="right"><h3><strong>wave</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Modifies the pixels along a sine wave.
</p>
<p></p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>src</i></TD><TD align="left" valign="top">The QImage to process.
</TD></TR>
<TR><TD align="left" valign="top"><i>amplitude</i></TD><TD align="left" valign="top">The amplitude of the sine wave.
</TD></TR>
<TR><TD align="left" valign="top"><i>wavelength</i></TD><TD align="left" valign="top">The frequency of the sine wave.
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The new image. The original is not changed.
      </p>
<A NAME="lHash"></A><A NAME="ref48"></A><table width="100%"><tr bgcolor="#eeeeee"><td> unsigned int &nbsp;<strong>lHash</strong> (unsigned int c)
<br></td><td align="right"><h3><strong>lHash</strong></h3></td></tr></table><p> <small>[private static]</small></p><p>
 Helper function to fast calc some altered (lighten, shaded) colors
</p>
<p>     </p>
<A NAME="uHash"></A><A NAME="ref49"></A><table width="100%"><tr bgcolor="#eeeeee"><td> unsigned int &nbsp;<strong>uHash</strong> (unsigned int c)
<br></td><td align="right"><h3><strong>uHash</strong></h3></td></tr></table><p> <small>[private static]</small></p><A NAME="nearestColor"></A><A NAME="ref50"></A><table width="100%"><tr bgcolor="#eeeeee"><td> int &nbsp;<strong>nearestColor</strong> ( int r, int g, int b, const <A HREF="#QColor">QColor</A> *pal, int size )
<br></td><td align="right"><h3><strong>nearestColor</strong></h3></td></tr></table><p> <small>[private static]</small></p><p>
 Helper function to find the nearest color to the RBG triplet
     </p>
<A NAME="hull"></A><A NAME="ref51"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>hull</strong> (const int x_offset, const int y_offset, const int polarity,
                     const int width, const int height,
                     unsigned int *f, unsigned int *g)
<br></td><td align="right"><h3><strong>hull</strong></h3></td></tr></table><p> <small>[private static]</small></p><A NAME="generateNoise"></A><A NAME="ref52"></A><table width="100%"><tr bgcolor="#eeeeee"><td> unsigned int &nbsp;<strong>generateNoise</strong> (unsigned int pixel, NoiseType type)
<br></td><td align="right"><h3><strong>generateNoise</strong></h3></td></tr></table><p> <small>[private static]</small></p><A NAME="interpolateColor"></A><A NAME="ref53"></A><table width="100%"><tr bgcolor="#eeeeee"><td> unsigned int &nbsp;<strong>interpolateColor</strong> (<A HREF="#QImage">QImage</A> *image, double x, double y,
                                         unsigned int background)
<br></td><td align="right"><h3><strong>interpolateColor</strong></h3></td></tr></table><p> <small>[private static]</small></p><HR>
	<table>
	<tr><td><small>Generated by: paul on T6.linux on Tue Mar 18 23:32:13 2003, using kdoc 2.0a54.</small></td></tr>
	</table>
</BODY>
</HTML>

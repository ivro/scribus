//
//  Little cms - profiler construction set
//  Copyright (C) 1998-2001 Marti Maria
//
// THIS SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
// EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
// WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
//
// IN NO EVENT SHALL MARTI MARIA BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
// INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
// OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
// WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF
// LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
// OF THIS SOFTWARE.
//
// This file is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, ma 02111-1307, USA.
//
// As a special exception to the GNU General Public License, if you
// distribute this file as part of a program that contains a
// configuration script generated by Autoconf, you may include it under
// the same distribution terms that you use for the rest of that program.
//
// Version 1.09a

#include "lcmsprf.h"


// From "numerical recipes in C"
// 
// Levenberg-Marquardt method, attempting to reduce the value X2 of a 
// fit between a set of data points x[1..ndata], y[1..ndata] with individual 
// standard deviations sig[1..ndata], and a nonlinear function dependent 
// on ma coefficients a[1..ma]. The input array ia[1..ma]
// indicates by nonzero entries those components of a that should be 
// fitted for, and by zero entries those components that should be held 
// fixed at their input values. The program returns current best-fitt 
// values for the parameters a[1..ma], and chisq. The arrays
// covar[1..ma][1..ma], alpha[1..ma][1..ma] are used as 
// working space  during most iterations. Supply a routine 
// funcs(x, a, yfit, dyda, ma) 
// that evaluates the fitting function yfit, and its derivatives dyda[1..ma] 
// with respect to the fitting parameters a at x. On the first call provide 
// an initial guess for the parameters a, and set alamda<0 for initialization
// (which then sets alamda=.001). If a step succeeds chisq becomes smaller 
// and alamda decreases by a factor of 10. If a step fails alamda grows by 
// a factor of 10. You must call this routine repeatedly until convergence 
// is achieved. Then, make one final call with alamda=0, so that 
// covar[1..ma][1..ma] returns the covar matrix, and alpha the 
// alpha matrix. (Parameters held fixed will return zero covariances.)


LCMSHANDLE cdecl cmsxLevenbergMarquardtInit(LPSAMPLEDCURVE x, LPSAMPLEDCURVE y, double sig,
								double a[],
								int ma,  
								void (*funcs)(double, double[], double*, double[], int)
								);

double    cdecl cmsxLevenbergMarquardtAlamda(LCMSHANDLE hMRQ);
double    cdecl cmsxLevenbergMarquardtChiSq(LCMSHANDLE hMRQ);
BOOL      cdecl cmsxLevenbergMarquardtIterate(LCMSHANDLE hMRQ);
BOOL      cdecl cmsxLevenbergMarquardtFree(LCMSHANDLE hMRQ);

// ----------------------------------------------------------------------------



typedef struct {

	LPSAMPLEDCURVE x;
	LPSAMPLEDCURVE y;		     
	int     ndata;  	 
	double* a;		     
	int     ma;
	LPMATN  covar;		 
	LPMATN  alpha;		 
	double* atry;		 
	LPMATN  beta;		 
	LPMATN  oneda;		 
	double* dyda;	 	 		
	double  ochisq;
	double  sig;


	void (*funcs)(double, double[], double*, double[], int); 

	double alamda;
	double chisq;

} LMRQMIN, FAR* LPLMRQMIN;




static 
void  mrqcof(LPLMRQMIN pLM, double *a, LPMATN alpha, LPMATN beta, double *chisq)
{
	int i, j, k;
	double ymod, wt, sig2i, dy;

	for(j = 0; j < pLM->ma; j++)
	{
		for(k = 0; k <= j; k++)
			alpha->Values[j][k] = 0.0;

		beta->Values[j][0] = 0.0;
	}
	
	*chisq = 0.0;
	sig2i = 1.0 / (pLM->sig * pLM->sig);

	for(i = 0; i < pLM->ndata; i++)
	{
		(*(pLM->funcs))(pLM->x ->Values[i], a, &ymod, pLM->dyda, pLM->ma);

		dy = pLM->y->Values[i] - ymod;

		for(j = 0; j < pLM->ma; j++)
		{
			wt = pLM->dyda[j] * sig2i;
			
			for(k = 0; k <= j; k++)
				alpha->Values[j][k] += wt * pLM->dyda[k];

			beta->Values[j][0] += dy * wt;
		}

		*chisq += dy * dy * sig2i;  
	}

	for(j = 1; j < pLM->ma; j++)	// Fill in the symmetric side.
		for(k = 0; k < j; k++)
			alpha->Values[k][j] = alpha->Values[j][k];
}



static 
void FreeStruct(LPLMRQMIN pLM)
{	
	if(pLM == NULL) return;

	if(pLM->covar) MATNfree (pLM->covar);
	if(pLM->alpha) MATNfree (pLM->alpha);
	if(pLM->atry)  free(pLM->atry);
	if(pLM->beta)  MATNfree (pLM->beta);
	if(pLM->oneda) MATNfree (pLM->oneda);
	if(pLM->dyda)  free(pLM->dyda);
	free(pLM);
}



LCMSHANDLE cmsxLevenbergMarquardtInit(LPSAMPLEDCURVE x, LPSAMPLEDCURVE y, double sig,
							double a[],
							int ma,  
							void (*funcs)(double, double[], double*, double[], int))
							
{
	int i;
	LPLMRQMIN pLM;
	
	if (x ->nItems != y ->nItems) return NULL;

	pLM = (LPLMRQMIN) malloc(sizeof(LMRQMIN));
	if(!pLM)
		return NULL;

	ZeroMemory(pLM, sizeof(LMRQMIN));
	
	if((pLM->atry = (double*)malloc(ma * sizeof(double))) == NULL) goto failed;
	if((pLM->beta = MATNalloc (ma, 1)) == NULL) goto failed;
	if((pLM->oneda = MATNalloc (ma, 1)) == NULL) goto failed;

	

	if((pLM->covar = MATNalloc(ma, ma)) == NULL) goto failed;
	if((pLM->alpha = MATNalloc(ma, ma)) == NULL) goto failed;		
	if((pLM->dyda = (double*)malloc(ma * sizeof(double))) == NULL) goto failed;

	pLM->alamda = 0.001;

	pLM->ndata = x ->nItems;
	pLM->x = x;
	pLM->y = y;
	pLM->ma = ma;
	pLM->a = a;
	pLM->funcs = funcs;
	pLM->sig = sig;
		
	mrqcof(pLM, a, pLM->alpha, pLM->beta, &pLM->chisq);	
	pLM->ochisq = (pLM->chisq);

	for(i = 0; i < ma; i++) pLM->atry[i] = a[i];

	return (LCMSHANDLE) pLM;

failed:
	FreeStruct(pLM);
	return NULL;
}


BOOL cmsxLevenbergMarquardtFree(LCMSHANDLE hMRQ)
{
	LPLMRQMIN pLM = (LPLMRQMIN)hMRQ;
	if(!pLM)
		return FALSE;

	FreeStruct(pLM);	
	return TRUE;
}


BOOL cmsxLevenbergMarquardtIterate(LCMSHANDLE hMRQ)
{
	int j, k;
	BOOL sts;
	LPLMRQMIN pLM = (LPLMRQMIN)hMRQ;
	if(!pLM)
		return FALSE;

	for(j = 0; j < pLM->ma; j++) // Alter linearized fitting matrix, by augmenting diagonal elements. 
	{
		for(k = 0; k < pLM->ma; k++)
			pLM->covar->Values[j][k] = pLM->alpha->Values[j][k];

		pLM->covar->Values[j][j] = pLM->alpha->Values[j][j] * (1.0 + pLM ->alamda);
		pLM->oneda->Values[j][0] = pLM->beta->Values[j][0];
	}
	
	if((sts = MATNsolve (pLM->covar, pLM->oneda)) != TRUE)  // Matrix solution.
		return sts;

	for(j = 0; j < pLM->ma; j++)							// Did the trial succeed?
		pLM->atry[j] = pLM->a[j] + pLM->oneda->Values[j][0];

	mrqcof(pLM, pLM->atry, pLM->covar, pLM->oneda, &pLM -> chisq);
	
	if (pLM->chisq < pLM->ochisq) {	 // Success, accept the new solution.

		pLM->alamda *= 0.1;
		pLM->ochisq = pLM->chisq;

		for(j = 0; j < pLM->ma; j++)
		{
			for(k = 0; k < pLM->ma; k++) 
				pLM->alpha->Values[j][k] = pLM->covar->Values[j][k];

			pLM->beta->Values[j][0] = pLM->oneda->Values[j][0];			
		}

		for (j=0; j < pLM ->ma; j++) pLM->a[j] = pLM->atry[j];
	}
	else   // Failure, increase alamda and return.
	{
		pLM -> alamda *= 10.0;
		pLM->chisq = pLM->ochisq;
	}
	
	return TRUE;
}


double cmsxLevenbergMarquardtAlamda(LCMSHANDLE hMRQ)
{
		LPLMRQMIN pLM = (LPLMRQMIN)hMRQ;

		return pLM ->alamda;
}

double cmsxLevenbergMarquardtChiSq(LCMSHANDLE hMRQ)
{
		LPLMRQMIN pLM = (LPLMRQMIN)hMRQ;

		return pLM ->chisq;
}
